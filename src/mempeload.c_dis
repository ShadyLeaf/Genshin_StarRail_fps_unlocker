

static DWORD64 load_pe(LPVOID pe_data)
{
    DWORD64 result_load = -1;
    PIMAGE_DOS_HEADER dos = (PIMAGE_DOS_HEADER)pe_data;
    PIMAGE_NT_HEADERS nt = (PIMAGE_NT_HEADERS)((PBYTE)pe_data + dos->e_lfanew);
    if (nt->FileHeader.Machine != IMAGE_FILE_MACHINE_AMD64)
    {
        return -2;
    }
    DWORD image_size = nt->OptionalHeader.SizeOfImage;

    LPVOID base = VirtualAllocEx_Internal((HANDLE)-1, NULL, image_size, PAGE_READWRITE);
    if (!base) return -3;

    //copy pe header
    memmove(base, pe_data, nt->OptionalHeader.SizeOfHeaders);

    //copy section data
    PIMAGE_SECTION_HEADER section = IMAGE_FIRST_SECTION(nt);
    for (WORD i = 0; i < nt->FileHeader.NumberOfSections; i++)
    {
        if (section[i].SizeOfRawData)
        {
            memmove((PBYTE)base + section[i].VirtualAddress, (PBYTE)pe_data + section[i].PointerToRawData, section[i].SizeOfRawData);
        }
    }

    //Handle relocations
    DWORD_PTR delta = (DWORD_PTR)base - nt->OptionalHeader.ImageBase;
    if (delta && nt->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size)
    {
        PIMAGE_BASE_RELOCATION reloc = (PIMAGE_BASE_RELOCATION)((PBYTE)base + nt->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress);
        while (reloc->VirtualAddress && reloc->SizeOfBlock > 0)
        {
            DWORD count = (reloc->SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION)) / sizeof(WORD);
            PWORD items = (PWORD)(reloc + 1);
            for (DWORD i = 0; i < count; i++)
            {
                BYTE type = items[i] >> 12;
                DWORD offset = items[i] & 0xFFF;
                if (type == IMAGE_REL_BASED_DIR64)
                {
                    PDWORD_PTR ptr = (PDWORD_PTR)((PBYTE)base + reloc->VirtualAddress + offset);
                    *ptr += delta;
                }
            }
            reloc = (PIMAGE_BASE_RELOCATION)((PBYTE)reloc + reloc->SizeOfBlock);
        }
    }

    //Handle imports
    if (nt->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].Size)
    {
        PIMAGE_IMPORT_DESCRIPTOR import = (PIMAGE_IMPORT_DESCRIPTOR)((PBYTE)base + nt->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress);
        while (import->Name)
        {
            PCHAR name = (PCHAR)base + import->Name;
            HMODULE module = LoadLibraryA(name);
            if (!module)
            {
                result_load = -6;
                goto __failed_exit;
            }
            PIMAGE_THUNK_DATA thunk = (PIMAGE_THUNK_DATA)((PBYTE)base + import->FirstThunk);
            if (import->OriginalFirstThunk)
            {
                PIMAGE_THUNK_DATA orig = (PIMAGE_THUNK_DATA)((PBYTE)base + import->OriginalFirstThunk);
                while (orig->u1.AddressOfData)
                {
                    FARPROC function = NULL;
                    if (orig->u1.Ordinal & IMAGE_ORDINAL_FLAG64)
                    {
                        function = GetProcAddress_Internal(module, (LPCSTR)(orig->u1.Ordinal & 0xFFFF));
                        if (!function)
                        {
                            result_load = -4;
                            goto __failed_exit;
                        }
                    }
                    else
                    {
                        PIMAGE_IMPORT_BY_NAME by_name = (PIMAGE_IMPORT_BY_NAME)((PBYTE)base + orig->u1.AddressOfData);
                        function = GetProcAddress_Internal(module, by_name->Name);
                        if (!function)
                        {
                            result_load = -4;
                            goto __failed_exit;
                        }
                    }
                    thunk->u1.Function = (ULONGLONG)function;
                    orig++;
                    thunk++;
                }
            }
            import++;
        }
    }

    //Handle section mem protection
    for (WORD i = 0; i < nt->FileHeader.NumberOfSections; i++)
    {
        DWORD old_protect;
        DWORD protect = 0;
        DWORD characteristics = section[i].Characteristics;
        if (characteristics & IMAGE_SCN_MEM_EXECUTE)
            protect = characteristics & IMAGE_SCN_MEM_WRITE ? PAGE_EXECUTE_READWRITE : PAGE_EXECUTE_READ;
        else
            protect = characteristics & IMAGE_SCN_MEM_WRITE ? PAGE_READWRITE : PAGE_READONLY;
        VirtualProtectEx_Internal((HANDLE)-1, (PBYTE)base + section[i].VirtualAddress, section[i].Misc.VirtualSize, protect, &old_protect);
    }

    if(1)
    {
        //Handle TLS callbacks
        PIMAGE_TLS_DIRECTORY tls = (PIMAGE_TLS_DIRECTORY)((PBYTE)base + nt->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].VirtualAddress);
        if (tls)
        {
            PIMAGE_TLS_CALLBACK* callbacks = (PIMAGE_TLS_CALLBACK*)tls->AddressOfCallBacks;
            if (callbacks)
            {
                for (PIMAGE_TLS_CALLBACK* callback = callbacks; *callback; callback++)
                {
                    (*callback)(base, DLL_PROCESS_ATTACH, NULL);
                }
            }
        }
    }

    //call oep
    if (nt->OptionalHeader.AddressOfEntryPoint)
    {
        typedef BOOL(WINAPI* DLLMain)(HMODULE hModule, DWORD dwReason, LPVOID lpReserved);
        DLLMain entry = (DLLMain)((PBYTE)base + nt->OptionalHeader.AddressOfEntryPoint);
        result_load = entry((HMODULE)base, DLL_PROCESS_ATTACH, NULL);
    }
    if (result_load)
    {
        return (DWORD64)base;
    }
    result_load = -5;

__failed_exit:
    VirtualFreeEx_Internal((HANDLE)-1, base, 0, MEM_RELEASE);
    return result_load;
}
